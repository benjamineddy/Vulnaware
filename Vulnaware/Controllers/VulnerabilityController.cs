using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Dynamic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Vulnaware.Data;
using Vulnaware.Models;
using System.Linq.Dynamic.Core;
using System.Linq.Expressions;
using System.Security.Claims;
using Microsoft.EntityFrameworkCore;
using Microsoft.AspNetCore.Identity;

namespace Vulnaware.Controllers
{
    [AllowAnonymous]
    public class VulnerabilityController : Controller
    {
        private readonly DatabaseContext _context;
        private readonly UserManager<ApplicationUser> _userManager;

        public VulnerabilityController(DatabaseContext context, UserManager<ApplicationUser> userManager)
        {
            _context = context;
            _userManager = userManager;
        }

        public IActionResult Index()
        {
            return View();
        }


        // Coded with assistance from https://www.c-sharpcorner.com/article/using-jquery-datatables-grid-with-asp-net-core-mvc/
        [HttpPost]
        public IActionResult LoadData()
        {
            try
            {
                var draw = HttpContext.Request.Form["draw"].FirstOrDefault();

                // Skip number of rows count
                var start = Request.Form["start"].FirstOrDefault();

                // Paging length 10,20
                var length = Request.Form["length"].FirstOrDefault();

                // Sort column name
                var sortColumn = Request.Form["columns[" + Request.Form["order[0][column]"]
                    .FirstOrDefault() + "][name]"].FirstOrDefault();

                // Sort column direction (asc, desc)
                var sortColumnDirection = Request.Form["order[0][dir]"].FirstOrDefault();

                // Search value from (search box)  
                var searchValue = Request.Form["search[value]"].FirstOrDefault();

                // Paging Size (10, 20, 50,100)  
                int pageSize = length != null ? Convert.ToInt32(length) : 0;

                int skip = start != null ? Convert.ToInt32(start) : 0;

                int recordsTotal = 0;

                // Get all vulnerability data
                var vulnerabilityList = _context.Cves.AsQueryable<Cve>();

                // Sorting
                if (!(string.IsNullOrEmpty(sortColumn) && string.IsNullOrEmpty(sortColumnDirection)))
                {
                    switch(sortColumn)
                    {
                        case "GivenID":
                            if (sortColumnDirection == "asc")
                            {
                                vulnerabilityList = vulnerabilityList.OrderBy(vl => vl.GivenID);
                                break;
                            }
                            else
                            {
                                vulnerabilityList = vulnerabilityList.OrderByDescending(vl => vl.GivenID);
                                break;
                            }
                        case "BaseScore":
                            if (sortColumnDirection == "asc")
                            {
                                vulnerabilityList = vulnerabilityList.OrderBy(vl => vl.BaseScore);
                                break;
                            } else
                            {
                                vulnerabilityList = vulnerabilityList.OrderByDescending(vl => vl.BaseScore);
                                break;
                            }
                        case "PublishedDate":
                            if (sortColumnDirection == "asc")
                            {
                                vulnerabilityList = vulnerabilityList.OrderBy(vl => vl.PublishedDate);
                                break;
                            } else
                            {
                                vulnerabilityList = vulnerabilityList.OrderByDescending(vl => vl.PublishedDate);
                                break;
                            }
                    }
                }

                // Search
                if (!string.IsNullOrEmpty(searchValue))
                {
                    vulnerabilityList = vulnerabilityList.Where(vl => vl.GivenID.Contains(searchValue)
                        || vl.IntegrityImpact.Contains(searchValue)
                        || vl.AccessComplexity.Contains(searchValue)
                        || vl.AccessVector.Contains(searchValue)
                        || vl.Authentication.Contains(searchValue)
                        || vl.AvailabilityImpact.Contains(searchValue)
                        || vl.ConfidentialityImpact.Contains(searchValue));
                }

                // Set row count
                recordsTotal = vulnerabilityList.Count();

                // Set paging
                var data = vulnerabilityList.Skip(skip).Take(pageSize).ToList();

                // Return Json data
                return Json(new { draw = draw, recordsFiltered = recordsTotal, recordsTotal = recordsTotal, data = data });

            } catch (Exception)
            {
                throw;
            }
        }

        [HttpGet]
        public IActionResult Details(int id)
        {
            // Get related CVE's
            Cve cve = _context.Cves
                .Where(c => c.CveID == id)
                .Include(c => c.References)
                .Include(c => c.CveConfigurations)
                .ThenInclude(cc => cc.Product)
                .FirstOrDefault();

            if (cve == null)
            {
                TempData["Param"] = "Vulnerability";
                TempData["Error"] = "Vulnerability does not exist";
                return RedirectToAction("Error", "Home");
            }

            return View(cve);
        }

        [HttpPost]
        [Authorize]
        public IActionResult ChangeVulnerabilityTracking(int cveID)
        {
            string aspNetUserID = _userManager.GetUserId(User);
            // Get existingTrackedCve if it exists
            var existingTrackedCve = _context.TrackedCves
                    .Where(tc => tc.AspNetUserID == aspNetUserID
                        && tc.CveID == cveID)
                    .FirstOrDefault();

            // It it does exist, remove it
            if (existingTrackedCve != null)
            {
                try
                {
                    _context.TrackedCves.Remove(existingTrackedCve);
                    _context.SaveChanges();
                }
                catch (DbUpdateConcurrencyException e)
                {
                    TempData["Param"] = "Changing Tracking";
                    TempData["Error"] = e.Message;
                    throw e;
                }
                catch (DbUpdateException e)
                {
                    TempData["Param"] = "Changing Tracking";
                    TempData["Error"] = e.Message;
                    throw e;
                }

                // true if added
                return Json(new { returnValue = "Removed" });
            } else // If it doesn't exist, add it
            {
                var newTrackedCve = new TrackedCve()
                {
                    AspNetUserID = aspNetUserID,
                    CveID = cveID
                };
                try
                {
                    _context.Add(newTrackedCve);
                    _context.SaveChanges();
                }
                catch (DbUpdateConcurrencyException e)
                {
                    TempData["Param"] = "Changing Tracking";
                    TempData["Error"] = e.Message;
                    throw e;
                }
                catch (DbUpdateException e)
                {
                    TempData["Param"] = "Changing Tracking";
                    TempData["Error"] = e.Message;
                    throw e;
                }

                // false if removed
                return Json(new { returnValue = "Added" });
            }
        }



        [HttpPost]
        [Authorize]
        public bool CheckExistingTracking(int cveID)
        {
            // Get existingTrackedCve
            try
            {
                TrackedCve existingTrackedCve = _context.TrackedCves
                    .Where(tc => tc.AspNetUserID == _userManager.GetUserId(User)
                        && tc.CveID == cveID)
                    .FirstOrDefault();

                // If it exists return true otherwise false
                if (existingTrackedCve != null)
                {
                    return true;
                } else
                {
                    return false;
                }
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}